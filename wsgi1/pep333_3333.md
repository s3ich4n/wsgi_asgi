# PEP 333, PEP 3333

+ 웹 서버와 파이썬 웹 앱/프레임워크와의 인터페이스를 제안한 문서
  + 이 문서는 2003년에 최초로 생성되었다
+ Python 3 버전에 맞추어서 새로 나온 PEP 3333을 같이 봐야한다

## Rationale and Goals

+ 그 시절 파이썬도 웹 애플리케이션이 많이 등장했으나, 웹 서버-웹 앱의 선택이 한정적이었다.
+ 그 시절 자바는 servlet API 를 통해 어떤 자바 앱이든 servlet API 로 웹 서버-웹 앱 간 상호작용이 가능했다.
+ 옛날 파이썬은 웹 통신을 위한 구현체가 따로따로 있었다
  + 예를 들어...
    + 파이썬으로 작성된 웹서버 ([Medusa, 아카이브](https://github.com/lispyclouds/medusa))
    + 웹 서버에 임베딩되어 쓰이는 형식 ([mod_python, 코드는 관리되나 더이상 업데이트 없음](https://github.com/grisha/mod_python))
    + 게이트웨이 프로토콜을 통해 파이썬을 호출한 방식 ([CGI, 정의만 있음](https://www.w3.org/CGI/), FastCGI)
      + CGI(Common Gateway Interface)는 다음에 더 추가적으로 설명하도록 한다...
+ PEP 333은 이런 불편을 덜기 위해 **_웹 서버-웹 앱 간의 인터페이스를 WSGI(Python Web Server Gateway Interface)를 제안_** 한 내용이다.
+ 그 외의 내용은 실제 WSGI를 설계 및 구현시에 관련된 내용이므로 과감히 생략하도록 한다.

## Specification Overview

+ WSGI 인터페이스는 "서버(혹은 게이트웨이)" 사이드, "앱(혹은 프레임워크) 사이드" 가 있다.
+ 서버 사이드는 `Callable` 객체[1]를 호출한다. 이 객체는 앱 사이드에서 제공하는 값이다.
  + Callable 객체가 어떻게 제공되는지는 서버/게이트웨이가 하기 나름이다.
    + 일부 서버 또는 게이트웨이는 응용 프로그램 배포자가 서버 또는 게이트웨이의 인스턴스를 만들고
      응용 프로그램 개체와 함께 제공하는 짧은 스크립트를 작성해야 한다고 가정. 
    + 다른 서버 및 게이트웨이는 구성 파일 또는 기타 메커니즘을 사용하여 응용 프로그램 개체를 가져오거나
      다른 방식으로 가져와야 하는 위치를 지정할 수 있음.
+ 서버/게이트웨이, 앱/프레임워크 사이에 존재하는 "미들웨어"라는 것을 구현할 수 있다
  + 이는 "미들웨어"를 포함하는 서버의 앱처럼 쓰일 수도 있다
  + 확장 API, 컨텐츠 변환, 탐색 등의 기타 유용한 기능을 추가로 제공해줄 수 있다

---

[1] `Callable`객체: `__call__()` 메소드를 구현한 객체를 의미한다.
  + 구현은 알아서 하면 되지만, 호출할 때는 어떤 종류의 `Callable`이 호출되었는지 알지 모르게 해야한다(종속성 제거).
  + 해당 콜러블은 자체검사되진 않는다

### `String` 타입 처리에 대하여

+ HTTP 는 일반적으로 `bytes` 처리를 한다. 이말은, 이 스펙의 경우 `bytes` 객체를 처리하는것과 연관있다는 뜻이다.

+ 많은 파이썬 구현체는 3.x 버전 이상에서는 문자열이 유니코드로 처리된다.
  + 코드 작성자는 API와 HTTP 컨텍스트간 번역을 잘 작성해야한다.
  + 파이썬 구현체 간의 다른 `str` 처리를 위해서라도 잘 처리해야한다.
+ 그러므로, WSGI는 두가지 "문자열"을 정의한다.
  + 요청/응답 헤더 및 메타데이터에 쓰이는 네이티브 문자열("Native" 문자열)
  + 요청/응답 본문에 쓰이는 바이트 문자열(`Bytestrings`)
  + 그러나, 내부적으로 유니코드로 어찌 처리되든간에
    파이썬 `str` 유형은 `Latin-1` 인코딩을 통해 바이트로 변환 가능해야한다. (하기 내용 참고)
    + "문자열"은 "Native" 문자열로
    + `bytestrings` 처리는...
      + Python 3에서는 `bytes` 로
      + Python 2에서는 `str` 유형의 객체로

### 미들웨어

+ 단일 객체는 다른 애플리케이션(들)에 대해 서버역할과 동시에 응용프로그램 역할을 할 수 있다.
+ 이러한 "미들웨어"는 아래 작동을 할 수 있다:
  + environ객체를 다시 재작성 후, 요청을 다른 애플리케이션 객체에 URL에 근거하여 라우팅
  + 여러 애플리케이션 혹은 프레임워크가 동일한 프로세스에서 나란히(?) 실행되도록 허용
  + 요청, 응답을 네트워크를 통해 포워딩 하는 것으로 로드밸런싱, 리모트 프로세싱
  + 컨텍스트 포스트-프로세싱 수행(e.g. XSL 스타일시트를 수행)
+ 일반적인 미들웨어의 존재는 서버/게이트웨이, 애플리케이션/프레임워크의 인터페이스 서로간 투명해야하고, 추가적인 지원이 필요하다.
+ 미들웨어를 앱에 포함하려는 유저는 미들웨어 컴포넌트를 마치 애플리케이션이 있는 것처럼 서버에 추가한다.
  그리고 마치 미들웨어 컴포넌트가 서버인 것 처럼, 미들웨어 컴포넌트를 설정하여 앱을 호출한다.
+ 물론 미들웨어가 래핑하는 "애플리케이션"은 실제로 다른 애플리케이션을 래핑하는 또 다른 미들웨어 구성 요소일 수 있으며,
  이런 식으로 "미들웨어 스택"이라고 하는 것을 생성할 수 있다.
+ 대부분의 경우 미들웨어는 WSGI의 서버 측과 애플리케이션 측 모두의 제한 사항 및 요구 사항을 준수해야 한다.
  그러나 어떤 경우에는 미들웨어에 대한 요구 사항이 "순수" 서버
  또는 애플리케이션보다 더 엄격하며 이러한 사항은 미들웨어 스펙에 기재되어야 한다.

## 스펙 상세

+ 애플리케이션 객체는 아래 `positional argument`를 반드시 받아야 한다. PEP 333(3) 에서는 설명을 위해 이름에 `environ`, `start_response` 라고 썼으나, 이름이 반드시 같지 않아도 된다.
+ 서버/게이트웨이 객체는 **반드시** 애플리케이션 객체를 `positional argument` 형태로 구현해야 한다.

### `environ` 변수

+ dictionary 오브젝트
+ CGI-style 환경변수를 포함하고 있다.
+ 이 객체는 **반드시** `dict` 타입이어야 한다.
  + 서브클래스가 아님에 유의
  + `UserDict` 혹은, dictionary 에뮬레이션 객체 형식
+ 애플리케이션은 해당 객체를 원하는대로 수정할 수 있어야 한다.
+ dictionary 오브젝트는 아래 변수를 포함하고 있어야 한다.
   (필수) WSGI에서 요구하는 변수들, 이하 후술. 이 변수는 값이 빈 문자열이 아닌 한 반드시 존재해야 하며, 이 경우 아래에 달리 언급되지 않는 한 생략될 수 있다.
    
    |변수명|설명|
    |------|----|
    |`REQUEST_METHOD`|HTTP 요청 메소드(e.g. "GET", "POST"). 빈 값이 될 수 없음.|
    |`SCRIPT_NAME`||
    |`PATH_INFO`||
    |`QUERY_STRING`||
    |`CONTENT_TYPE`||
    |`CONTENT_LENGTH`||
    |`SERVER_NAME`, `SERVER_PORT`||
    |`SERVER_PROTOCOL`||
    |`HTTP_변수들`||

  + 후술할 네이밍 컨벤션을 따르는 서버 별 확장 변수

#### Input, Error 스트림

### `start_response` Callable.

+ 아래 두가지 positional argument, optional argument를 받을 수 있는 `Callable` 객체.
  + 설명을 위해 각각의 변수명은 `status`, `response_headers`, `exc_info` 로 기술하였으나, 이름이 반드시 같지 않아도 된다.
  + 애플리케이션은 **반드시** `start_response` `Callable` 을 `positional arguments` 로 호출해야 한다.
    + e.g. `start_response(status, response_headers)`
  + `status` 파라미터
    + `999 Message here` 형태의 status 문자열이다.
  + `response_headers` 파라미터
    + `list(header_name, header_value)` 형식의 tuple 이다.
    + HTTP Response 응답값 표현방식이다.
  + `exc_info`
    + 하기 Deep-dive `start_response()` Callable 에서 상세히 설명한다.
    + 에러 핸들링에서 상세히 설명한다.
+ `write(body_data)` 를 **반드시** 리턴해야한다. 
  + `body_data` 는 `positional parameter` 이다.
  + 이 값은 HTTP response body의 일부로 쓰일 bytestring이다.
  + `write()` Callable 은 몇몇 기존 프레임워크의 명령형 출력 API에만 쓰인다.
    안 쓸 수 있으면 새 애플리케이션/프레임워크 에서는 쓰이면 안된다.
    + 버퍼링, 스트리밍 란에서 후술한다.
+ 이 아래부터는 일단 PEP 333(3)을 스스로 번역해보면서 쓴 내용이다.
+ 서버가 호출 시 애플리케이션은 0 혹은 bytestring 을 `yield` 하는 이터러블을 리턴해야한다.
+ 서버/게이트웨이는 생성된 bytestring 은 버퍼링되지 않은 방식으로 클라이언트에 보내야함.
  + 애플리케이션에서 자체 버퍼링을 해야함. 버퍼링, 스트리밍 란에서 후술한다.
+ 서버/게이트웨이는 bytestring 을 리턴할 때는 binary byte sequence 로 리턴해야 한다.
  + 이 때, line ending을 잘 살펴봐야 한다
+ `len(iterable)` 호출이 성공하면, 서버는 정확한 결과를 받아봐야 한다.
  + (`Content-Length` 의 길이를 의미)
+ 이터러블이 `close()` 메소드를 호출하면 서버/게이트웨이는 요청 완료 시 해당 메소드를 종료해야 한다.
  + 정상종료, 오류, 연결해제 등에 관계없이...
  + close() 메소드 요구 사항은 응용 프로그램에 의한 리소스 해제를 지원하는 것.
  + 이 프로토콜은 PEP 342의 제너레이터 지원 및 close() 메소드 사용하는 기타 일반적인 이터러블을 보완하기 위한 것.
+ 제너레이터 혹은 커스텀 이터레이터를 리턴하는 애플리케이션은 모든 이터레이터가 consume 되었다고 가정하면 안된다. 왜냐하면 이미 서버에서 close 했을 수 있기 때문.
+ 이 아래는 뭔소린지 모르겠다..
+ (참고: 애플리케이션은 iterable이 첫 번째 본문 바이트열을 생성하기 전에 start_response() 호출 가능을 호출해야 서버가 본문 내용보다 먼저 헤더를 보낼 수 있습니다. 그러나 이 호출은 iterable의 첫 번째 반복에서 수행될 수 있으므로 서버는 반드시 iterable에 대해 반복을 시작하기 전에 start_response()가 호출되었다고 가정하지 마십시오.)
+ 마지막으로 서버와 게이트웨이는 `wsgi.file_wrapper`에 의해 반환된 "파일 래퍼"와 같이 해당 서버나 게이트웨이에 특정한 유형의 인스턴스가 아닌 한 애플리케이션이 반환한 이터러블의 다른 속성을 직접 사용해서는 안 됩니다(선택 사항 참조 플랫폼별 파일 처리). 일반적으로 여기에 지정되거나 예를 들어 PEP 234 반복 API가 허용됩니다. 

#### Deep-dive `start_response()` Callable 

+ 

#### 에러 핸들링

#### `Content-Length` 헤더 처리

### 버퍼링, 스트리밍

### 유니코드 처리

### 에러 처리

### HTTP 1.1 "expect/continue" 메커니즘 처리
